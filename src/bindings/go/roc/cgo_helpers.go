// WARNING: This file has automatically been generated on Sat, 05 Oct 2019 17:36:41 CEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package roc

/*
#cgo linux CFLAGS: -I"../../../lib/include"
#cgo linux LDFLAGS: -L"../../../build/x86_64-pc-redhat-linux/gcc-9.1.1-release" -lroc
#include "../../../lib/include/roc/address.h"
#include "../../../lib/include/roc/config.h"
#include "../../../lib/include/roc/context.h"
#include "../../../lib/include/roc/frame.h"
#include "../../../lib/include/roc/log.h"
#include "../../../lib/include/roc/platform.h"
#include "../../../lib/include/roc/receiver.h"
#include "../../../lib/include/roc/sender.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocAddressMemory allocates memory for type C.roc_address in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAddressMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAddressValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAddressValue = unsafe.Sizeof([1]C.roc_address{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Address) Ref() *C.roc_address {
	if x == nil {
		return nil
	}
	return x.ref94efe9d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Address) Free() {
	if x != nil && x.allocs94efe9d7 != nil {
		x.allocs94efe9d7.(*cgoAllocMap).Free()
		x.ref94efe9d7 = nil
	}
}

// NewAddressRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAddressRef(ref unsafe.Pointer) *Address {
	if ref == nil {
		return nil
	}
	obj := new(Address)
	obj.ref94efe9d7 = (*C.roc_address)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Address) PassRef() (*C.roc_address, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref94efe9d7 != nil {
		return x.ref94efe9d7, nil
	}
	mem94efe9d7 := allocAddressMemory(1)
	ref94efe9d7 := (*C.roc_address)(mem94efe9d7)
	allocs94efe9d7 := new(cgoAllocMap)
	allocs94efe9d7.Add(mem94efe9d7)

	x.ref94efe9d7 = ref94efe9d7
	x.allocs94efe9d7 = allocs94efe9d7
	return ref94efe9d7, allocs94efe9d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Address) PassValue() (C.roc_address, *cgoAllocMap) {
	if x.ref94efe9d7 != nil {
		return *x.ref94efe9d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Address) Deref() {
	if x.ref94efe9d7 == nil {
		return
	}
}

// allocContextConfigMemory allocates memory for type C.roc_context_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfContextConfigValue = unsafe.Sizeof([1]C.roc_context_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ContextConfig) Ref() *C.roc_context_config {
	if x == nil {
		return nil
	}
	return x.ref6685576b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ContextConfig) Free() {
	if x != nil && x.allocs6685576b != nil {
		x.allocs6685576b.(*cgoAllocMap).Free()
		x.ref6685576b = nil
	}
}

// NewContextConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewContextConfigRef(ref unsafe.Pointer) *ContextConfig {
	if ref == nil {
		return nil
	}
	obj := new(ContextConfig)
	obj.ref6685576b = (*C.roc_context_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ContextConfig) PassRef() (*C.roc_context_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6685576b != nil {
		return x.ref6685576b, nil
	}
	mem6685576b := allocContextConfigMemory(1)
	ref6685576b := (*C.roc_context_config)(mem6685576b)
	allocs6685576b := new(cgoAllocMap)
	allocs6685576b.Add(mem6685576b)

	var cmax_packet_size_allocs *cgoAllocMap
	ref6685576b.max_packet_size, cmax_packet_size_allocs = (C.uint)(x.MaxPacketSize), cgoAllocsUnknown
	allocs6685576b.Borrow(cmax_packet_size_allocs)

	var cmax_frame_size_allocs *cgoAllocMap
	ref6685576b.max_frame_size, cmax_frame_size_allocs = (C.uint)(x.MaxFrameSize), cgoAllocsUnknown
	allocs6685576b.Borrow(cmax_frame_size_allocs)

	x.ref6685576b = ref6685576b
	x.allocs6685576b = allocs6685576b
	return ref6685576b, allocs6685576b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ContextConfig) PassValue() (C.roc_context_config, *cgoAllocMap) {
	if x.ref6685576b != nil {
		return *x.ref6685576b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ContextConfig) Deref() {
	if x.ref6685576b == nil {
		return
	}
	x.MaxPacketSize = (uint32)(x.ref6685576b.max_packet_size)
	x.MaxFrameSize = (uint32)(x.ref6685576b.max_frame_size)
}

// allocSenderConfigMemory allocates memory for type C.roc_sender_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSenderConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSenderConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSenderConfigValue = unsafe.Sizeof([1]C.roc_sender_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SenderConfig) Ref() *C.roc_sender_config {
	if x == nil {
		return nil
	}
	return x.refc92542a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SenderConfig) Free() {
	if x != nil && x.allocsc92542a4 != nil {
		x.allocsc92542a4.(*cgoAllocMap).Free()
		x.refc92542a4 = nil
	}
}

// NewSenderConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSenderConfigRef(ref unsafe.Pointer) *SenderConfig {
	if ref == nil {
		return nil
	}
	obj := new(SenderConfig)
	obj.refc92542a4 = (*C.roc_sender_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SenderConfig) PassRef() (*C.roc_sender_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc92542a4 != nil {
		return x.refc92542a4, nil
	}
	memc92542a4 := allocSenderConfigMemory(1)
	refc92542a4 := (*C.roc_sender_config)(memc92542a4)
	allocsc92542a4 := new(cgoAllocMap)
	allocsc92542a4.Add(memc92542a4)

	var cframe_sample_rate_allocs *cgoAllocMap
	refc92542a4.frame_sample_rate, cframe_sample_rate_allocs = (C.uint)(x.FrameSampleRate), cgoAllocsUnknown
	allocsc92542a4.Borrow(cframe_sample_rate_allocs)

	var cframe_channels_allocs *cgoAllocMap
	refc92542a4.frame_channels, cframe_channels_allocs = (C.roc_channel_set)(x.FrameChannels), cgoAllocsUnknown
	allocsc92542a4.Borrow(cframe_channels_allocs)

	var cframe_encoding_allocs *cgoAllocMap
	refc92542a4.frame_encoding, cframe_encoding_allocs = (C.roc_frame_encoding)(x.FrameEncoding), cgoAllocsUnknown
	allocsc92542a4.Borrow(cframe_encoding_allocs)

	var cpacket_sample_rate_allocs *cgoAllocMap
	refc92542a4.packet_sample_rate, cpacket_sample_rate_allocs = (C.uint)(x.PacketSampleRate), cgoAllocsUnknown
	allocsc92542a4.Borrow(cpacket_sample_rate_allocs)

	var cpacket_channels_allocs *cgoAllocMap
	refc92542a4.packet_channels, cpacket_channels_allocs = (C.roc_channel_set)(x.PacketChannels), cgoAllocsUnknown
	allocsc92542a4.Borrow(cpacket_channels_allocs)

	var cpacket_encoding_allocs *cgoAllocMap
	refc92542a4.packet_encoding, cpacket_encoding_allocs = (C.roc_packet_encoding)(x.PacketEncoding), cgoAllocsUnknown
	allocsc92542a4.Borrow(cpacket_encoding_allocs)

	var cpacket_length_allocs *cgoAllocMap
	refc92542a4.packet_length, cpacket_length_allocs = (C.ulonglong)(x.PacketLength), cgoAllocsUnknown
	allocsc92542a4.Borrow(cpacket_length_allocs)

	var cpacket_interleaving_allocs *cgoAllocMap
	refc92542a4.packet_interleaving, cpacket_interleaving_allocs = (C.uint)(x.PacketInterleaving), cgoAllocsUnknown
	allocsc92542a4.Borrow(cpacket_interleaving_allocs)

	var cautomatic_timing_allocs *cgoAllocMap
	refc92542a4.automatic_timing, cautomatic_timing_allocs = (C.uint)(x.AutomaticTiming), cgoAllocsUnknown
	allocsc92542a4.Borrow(cautomatic_timing_allocs)

	var cresampler_profile_allocs *cgoAllocMap
	refc92542a4.resampler_profile, cresampler_profile_allocs = (C.roc_resampler_profile)(x.ResamplerProfile), cgoAllocsUnknown
	allocsc92542a4.Borrow(cresampler_profile_allocs)

	var cfec_code_allocs *cgoAllocMap
	refc92542a4.fec_code, cfec_code_allocs = (C.roc_fec_code)(x.FecCode), cgoAllocsUnknown
	allocsc92542a4.Borrow(cfec_code_allocs)

	var cfec_block_source_packets_allocs *cgoAllocMap
	refc92542a4.fec_block_source_packets, cfec_block_source_packets_allocs = (C.uint)(x.FecBlockSourcePackets), cgoAllocsUnknown
	allocsc92542a4.Borrow(cfec_block_source_packets_allocs)

	var cfec_block_repair_packets_allocs *cgoAllocMap
	refc92542a4.fec_block_repair_packets, cfec_block_repair_packets_allocs = (C.uint)(x.FecBlockRepairPackets), cgoAllocsUnknown
	allocsc92542a4.Borrow(cfec_block_repair_packets_allocs)

	x.refc92542a4 = refc92542a4
	x.allocsc92542a4 = allocsc92542a4
	return refc92542a4, allocsc92542a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SenderConfig) PassValue() (C.roc_sender_config, *cgoAllocMap) {
	if x.refc92542a4 != nil {
		return *x.refc92542a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SenderConfig) Deref() {
	if x.refc92542a4 == nil {
		return
	}
	x.FrameSampleRate = (uint32)(x.refc92542a4.frame_sample_rate)
	x.FrameChannels = (ChannelSet)(x.refc92542a4.frame_channels)
	x.FrameEncoding = (FrameEncoding)(x.refc92542a4.frame_encoding)
	x.PacketSampleRate = (uint32)(x.refc92542a4.packet_sample_rate)
	x.PacketChannels = (ChannelSet)(x.refc92542a4.packet_channels)
	x.PacketEncoding = (PacketEncoding)(x.refc92542a4.packet_encoding)
	x.PacketLength = (uint64)(x.refc92542a4.packet_length)
	x.PacketInterleaving = (uint32)(x.refc92542a4.packet_interleaving)
	x.AutomaticTiming = (uint32)(x.refc92542a4.automatic_timing)
	x.ResamplerProfile = (ResamplerProfile)(x.refc92542a4.resampler_profile)
	x.FecCode = (FecCode)(x.refc92542a4.fec_code)
	x.FecBlockSourcePackets = (uint32)(x.refc92542a4.fec_block_source_packets)
	x.FecBlockRepairPackets = (uint32)(x.refc92542a4.fec_block_repair_packets)
}

// allocReceiverConfigMemory allocates memory for type C.roc_receiver_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocReceiverConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfReceiverConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfReceiverConfigValue = unsafe.Sizeof([1]C.roc_receiver_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ReceiverConfig) Ref() *C.roc_receiver_config {
	if x == nil {
		return nil
	}
	return x.ref9cfc9e50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ReceiverConfig) Free() {
	if x != nil && x.allocs9cfc9e50 != nil {
		x.allocs9cfc9e50.(*cgoAllocMap).Free()
		x.ref9cfc9e50 = nil
	}
}

// NewReceiverConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewReceiverConfigRef(ref unsafe.Pointer) *ReceiverConfig {
	if ref == nil {
		return nil
	}
	obj := new(ReceiverConfig)
	obj.ref9cfc9e50 = (*C.roc_receiver_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ReceiverConfig) PassRef() (*C.roc_receiver_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9cfc9e50 != nil {
		return x.ref9cfc9e50, nil
	}
	mem9cfc9e50 := allocReceiverConfigMemory(1)
	ref9cfc9e50 := (*C.roc_receiver_config)(mem9cfc9e50)
	allocs9cfc9e50 := new(cgoAllocMap)
	allocs9cfc9e50.Add(mem9cfc9e50)

	var cframe_sample_rate_allocs *cgoAllocMap
	ref9cfc9e50.frame_sample_rate, cframe_sample_rate_allocs = (C.uint)(x.FrameSampleRate), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cframe_sample_rate_allocs)

	var cframe_channels_allocs *cgoAllocMap
	ref9cfc9e50.frame_channels, cframe_channels_allocs = (C.roc_channel_set)(x.FrameChannels), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cframe_channels_allocs)

	var cframe_encoding_allocs *cgoAllocMap
	ref9cfc9e50.frame_encoding, cframe_encoding_allocs = (C.roc_frame_encoding)(x.FrameEncoding), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cframe_encoding_allocs)

	var cautomatic_timing_allocs *cgoAllocMap
	ref9cfc9e50.automatic_timing, cautomatic_timing_allocs = (C.uint)(x.AutomaticTiming), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cautomatic_timing_allocs)

	var cresampler_profile_allocs *cgoAllocMap
	ref9cfc9e50.resampler_profile, cresampler_profile_allocs = (C.roc_resampler_profile)(x.ResamplerProfile), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cresampler_profile_allocs)

	var ctarget_latency_allocs *cgoAllocMap
	ref9cfc9e50.target_latency, ctarget_latency_allocs = (C.ulonglong)(x.TargetLatency), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(ctarget_latency_allocs)

	var cmax_latency_overrun_allocs *cgoAllocMap
	ref9cfc9e50.max_latency_overrun, cmax_latency_overrun_allocs = (C.ulonglong)(x.MaxLatencyOverrun), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cmax_latency_overrun_allocs)

	var cmax_latency_underrun_allocs *cgoAllocMap
	ref9cfc9e50.max_latency_underrun, cmax_latency_underrun_allocs = (C.ulonglong)(x.MaxLatencyUnderrun), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cmax_latency_underrun_allocs)

	var cno_playback_timeout_allocs *cgoAllocMap
	ref9cfc9e50.no_playback_timeout, cno_playback_timeout_allocs = (C.longlong)(x.NoPlaybackTimeout), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cno_playback_timeout_allocs)

	var cbroken_playback_timeout_allocs *cgoAllocMap
	ref9cfc9e50.broken_playback_timeout, cbroken_playback_timeout_allocs = (C.longlong)(x.BrokenPlaybackTimeout), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cbroken_playback_timeout_allocs)

	var cbreakage_detection_window_allocs *cgoAllocMap
	ref9cfc9e50.breakage_detection_window, cbreakage_detection_window_allocs = (C.ulonglong)(x.BreakageDetectionWindow), cgoAllocsUnknown
	allocs9cfc9e50.Borrow(cbreakage_detection_window_allocs)

	x.ref9cfc9e50 = ref9cfc9e50
	x.allocs9cfc9e50 = allocs9cfc9e50
	return ref9cfc9e50, allocs9cfc9e50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ReceiverConfig) PassValue() (C.roc_receiver_config, *cgoAllocMap) {
	if x.ref9cfc9e50 != nil {
		return *x.ref9cfc9e50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ReceiverConfig) Deref() {
	if x.ref9cfc9e50 == nil {
		return
	}
	x.FrameSampleRate = (uint32)(x.ref9cfc9e50.frame_sample_rate)
	x.FrameChannels = (ChannelSet)(x.ref9cfc9e50.frame_channels)
	x.FrameEncoding = (FrameEncoding)(x.ref9cfc9e50.frame_encoding)
	x.AutomaticTiming = (uint32)(x.ref9cfc9e50.automatic_timing)
	x.ResamplerProfile = (ResamplerProfile)(x.ref9cfc9e50.resampler_profile)
	x.TargetLatency = (uint64)(x.ref9cfc9e50.target_latency)
	x.MaxLatencyOverrun = (uint64)(x.ref9cfc9e50.max_latency_overrun)
	x.MaxLatencyUnderrun = (uint64)(x.ref9cfc9e50.max_latency_underrun)
	x.NoPlaybackTimeout = (int64)(x.ref9cfc9e50.no_playback_timeout)
	x.BrokenPlaybackTimeout = (int64)(x.ref9cfc9e50.broken_playback_timeout)
	x.BreakageDetectionWindow = (uint64)(x.ref9cfc9e50.breakage_detection_window)
}

// Ref returns a reference to C object as it is.
func (x *Context) Ref() *C.roc_context {
	if x == nil {
		return nil
	}
	return (*C.roc_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Context) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewContextRef converts the C object reference into a raw struct reference without wrapping.
func NewContextRef(ref unsafe.Pointer) *Context {
	return (*Context)(ref)
}

// NewContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewContext() *Context {
	return (*Context)(allocContextMemory(1))
}

// allocContextMemory allocates memory for type C.roc_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfContextValue = unsafe.Sizeof([1]C.roc_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Context) PassRef() *C.roc_context {
	if x == nil {
		x = (*Context)(allocContextMemory(1))
	}
	return (*C.roc_context)(unsafe.Pointer(x))
}

// allocFrameMemory allocates memory for type C.roc_frame in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFrameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFrameValue = unsafe.Sizeof([1]C.roc_frame{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Frame) Ref() *C.roc_frame {
	if x == nil {
		return nil
	}
	return x.ref5cb6a60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Frame) Free() {
	if x != nil && x.allocs5cb6a60 != nil {
		x.allocs5cb6a60.(*cgoAllocMap).Free()
		x.ref5cb6a60 = nil
	}
}

// NewFrameRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFrameRef(ref unsafe.Pointer) *Frame {
	if ref == nil {
		return nil
	}
	obj := new(Frame)
	obj.ref5cb6a60 = (*C.roc_frame)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Frame) PassRef() (*C.roc_frame, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5cb6a60 != nil {
		return x.ref5cb6a60, nil
	}
	mem5cb6a60 := allocFrameMemory(1)
	ref5cb6a60 := (*C.roc_frame)(mem5cb6a60)
	allocs5cb6a60 := new(cgoAllocMap)
	allocs5cb6a60.Add(mem5cb6a60)

	var csamples_allocs *cgoAllocMap
	ref5cb6a60.samples, csamples_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Samples)), cgoAllocsUnknown
	allocs5cb6a60.Borrow(csamples_allocs)

	var csamples_size_allocs *cgoAllocMap
	ref5cb6a60.samples_size, csamples_size_allocs = (C.size_t)(x.SamplesSize), cgoAllocsUnknown
	allocs5cb6a60.Borrow(csamples_size_allocs)

	x.ref5cb6a60 = ref5cb6a60
	x.allocs5cb6a60 = allocs5cb6a60
	return ref5cb6a60, allocs5cb6a60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Frame) PassValue() (C.roc_frame, *cgoAllocMap) {
	if x.ref5cb6a60 != nil {
		return *x.ref5cb6a60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Frame) Deref() {
	if x.ref5cb6a60 == nil {
		return
	}
	x.Samples = (unsafe.Pointer)(unsafe.Pointer(x.ref5cb6a60.samples))
	x.SamplesSize = (uint)(x.ref5cb6a60.samples_size)
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x LogHandler) PassRef() (ref *C.roc_log_handler, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logHandler9E4BBC5EFunc == nil {
		logHandler9E4BBC5EFunc = x
	}
	return (*C.roc_log_handler)(C.roc_log_handler_9e4bbc5e), nil
}

func (x LogHandler) PassValue() (ref C.roc_log_handler, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if logHandler9E4BBC5EFunc == nil {
		logHandler9E4BBC5EFunc = x
	}
	return (C.roc_log_handler)(C.roc_log_handler_9e4bbc5e), nil
}

func NewLogHandlerRef(ref unsafe.Pointer) *LogHandler {
	return (*LogHandler)(ref)
}

//export logHandler9E4BBC5E
func logHandler9E4BBC5E(clevel C.roc_log_level, ccomponent *C.char, cmessage *C.char) {
	if logHandler9E4BBC5EFunc != nil {
		level9e4bbc5e := (LogLevel)(clevel)
		component9e4bbc5e := packPCharString(ccomponent)
		message9e4bbc5e := packPCharString(cmessage)
		logHandler9E4BBC5EFunc(level9e4bbc5e, component9e4bbc5e, message9e4bbc5e)
		return
	}
	panic("callback func has not been set (race?)")
}

var logHandler9E4BBC5EFunc LogHandler

// Ref returns a reference to C object as it is.
func (x *Receiver) Ref() *C.roc_receiver {
	if x == nil {
		return nil
	}
	return (*C.roc_receiver)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Receiver) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewReceiverRef converts the C object reference into a raw struct reference without wrapping.
func NewReceiverRef(ref unsafe.Pointer) *Receiver {
	return (*Receiver)(ref)
}

// NewReceiver allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewReceiver() *Receiver {
	return (*Receiver)(allocReceiverMemory(1))
}

// allocReceiverMemory allocates memory for type C.roc_receiver in C.
// The caller is responsible for freeing the this memory via C.free.
func allocReceiverMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfReceiverValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfReceiverValue = unsafe.Sizeof([1]C.roc_receiver{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Receiver) PassRef() *C.roc_receiver {
	if x == nil {
		x = (*Receiver)(allocReceiverMemory(1))
	}
	return (*C.roc_receiver)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Sender) Ref() *C.roc_sender {
	if x == nil {
		return nil
	}
	return (*C.roc_sender)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Sender) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSenderRef converts the C object reference into a raw struct reference without wrapping.
func NewSenderRef(ref unsafe.Pointer) *Sender {
	return (*Sender)(ref)
}

// NewSender allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSender() *Sender {
	return (*Sender)(allocSenderMemory(1))
}

// allocSenderMemory allocates memory for type C.roc_sender in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSenderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSenderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSenderValue = unsafe.Sizeof([1]C.roc_sender{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Sender) PassRef() *C.roc_sender {
	if x == nil {
		x = (*Sender)(allocSenderMemory(1))
	}
	return (*C.roc_sender)(unsafe.Pointer(x))
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSAddress transforms a sliced Go data structure into plain C format.
func unpackArgSAddress(x []Address) (unpacked *C.roc_address, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.roc_address) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAddressMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.roc_address)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.roc_address)(h.Data)
	return
}

// packSAddress reads sliced Go data structure out from plain C format.
func packSAddress(v []Address, ptr0 *C.roc_address) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAddressValue]C.roc_address)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAddressRef(unsafe.Pointer(&ptr1))
	}
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// unpackArgSContextConfig transforms a sliced Go data structure into plain C format.
func unpackArgSContextConfig(x []ContextConfig) (unpacked *C.roc_context_config, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.roc_context_config) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocContextConfigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.roc_context_config)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.roc_context_config)(h.Data)
	return
}

// packSContextConfig reads sliced Go data structure out from plain C format.
func packSContextConfig(v []ContextConfig, ptr0 *C.roc_context_config) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfContextConfigValue]C.roc_context_config)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewContextConfigRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSReceiverConfig transforms a sliced Go data structure into plain C format.
func unpackArgSReceiverConfig(x []ReceiverConfig) (unpacked *C.roc_receiver_config, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.roc_receiver_config) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocReceiverConfigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.roc_receiver_config)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.roc_receiver_config)(h.Data)
	return
}

// packSReceiverConfig reads sliced Go data structure out from plain C format.
func packSReceiverConfig(v []ReceiverConfig, ptr0 *C.roc_receiver_config) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfReceiverConfigValue]C.roc_receiver_config)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewReceiverConfigRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFrame transforms a sliced Go data structure into plain C format.
func unpackArgSFrame(x []Frame) (unpacked *C.roc_frame, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.roc_frame) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFrameMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.roc_frame)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.roc_frame)(h.Data)
	return
}

// packSFrame reads sliced Go data structure out from plain C format.
func packSFrame(v []Frame, ptr0 *C.roc_frame) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFrameValue]C.roc_frame)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFrameRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSenderConfig transforms a sliced Go data structure into plain C format.
func unpackArgSSenderConfig(x []SenderConfig) (unpacked *C.roc_sender_config, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.roc_sender_config) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSenderConfigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.roc_sender_config)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.roc_sender_config)(h.Data)
	return
}

// packSSenderConfig reads sliced Go data structure out from plain C format.
func packSSenderConfig(v []SenderConfig, ptr0 *C.roc_sender_config) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSenderConfigValue]C.roc_sender_config)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSenderConfigRef(unsafe.Pointer(&ptr1))
	}
}
